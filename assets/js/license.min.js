/* license.min.js — OFFLINE (HMAC) + Device Lock on First Activation
   Reemplazo directo para assets/js/license.min.js
*/
(function () {
  "use strict";

  // ========= CONFIG =========
  const STORAGE_KEY = "pclsoat_license_token_v1";
  const DEVICE_KEY  = "pclsoat_device_id_v1";
  const SECRET      = "Sk1nn3r%%2025"; // conserva tu secreto actual
  // ==========================

  // ---- b64url helpers ----
  function b64uEncodeBytes(bytes) {
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function b64uDecodeToBytes(b64u) {
    const b64 = b64u.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((b64u.length + 3) % 4);
    const str = atob(b64);
    const out = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) out[i] = str.charCodeAt(i);
    return out;
  }
  function utf8Bytes(s) { return new TextEncoder().encode(String(s)); }
  function utf8String(bytes) { return new TextDecoder().decode(bytes); }

  // ---- crypto ----
  async function sha256B64u(inputBytes) {
    const h = await crypto.subtle.digest("SHA-256", inputBytes);
    return b64uEncodeBytes(new Uint8Array(h));
  }
  async function hmacSha256B64u(messageBytes) {
    const key = await crypto.subtle.importKey(
      "raw",
      utf8Bytes(SECRET),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", key, messageBytes);
    return b64uEncodeBytes(new Uint8Array(sig));
  }

  // ---- date ----
  function parseISODate(iso) {
    if (!iso || typeof iso !== "string") return null;
    const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    const y = Number(m[1]), mo = Number(m[2]) - 1, d = Number(m[3]);
    const dt = new Date(Date.UTC(y, mo, d, 0, 0, 0));
    return isNaN(dt.getTime()) ? null : dt;
  }
  function daysLeft(expISO) {
    const exp = parseISODate(expISO);
    if (!exp) return NaN;
    const now = new Date();
    const nowUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0);
    const diffMs = exp.getTime() - nowUTC;
    return Math.floor(diffMs / 86400000);
  }

  // ---- device id ----
  function getOrCreateDeviceId() {
    let id = localStorage.getItem(DEVICE_KEY);
    if (id && id.length >= 16) return id;
    const buf = new Uint8Array(24);
    crypto.getRandomValues(buf);
    id = b64uEncodeBytes(buf);
    localStorage.setItem(DEVICE_KEY, id);
    return id;
  }
  async function deviceHashFor(lic_id) {
    const deviceId = getOrCreateDeviceId();
    return sha256B64u(utf8Bytes(`${lic_id}::${deviceId}`));
  }

  // ---- storage ----
  function loadToken() { return (localStorage.getItem(STORAGE_KEY) || "").trim(); }
  function saveToken(t) { localStorage.setItem(STORAGE_KEY, String(t || "").trim()); }
  function clearToken() { localStorage.removeItem(STORAGE_KEY); }

  // ---- device lock binding ----
  function bindKey(lic_id) { return `pclsoat_bound_device_${lic_id}`; }
  function getBound(lic_id) { return localStorage.getItem(bindKey(lic_id)) || ""; }
  function setBound(lic_id, h) { localStorage.setItem(bindKey(lic_id), String(h || "")); }

  // ---- verify signature payload.signature ----
  async function verifyTokenSignature(token) {
    const parts = String(token || "").split(".");
    if (parts.length !== 2) return { ok: false, reason: "Formato inválido (payload.signature)." };

    const payloadB64u = parts[0].trim();
    const sigB64u = parts[1].trim();
    if (!payloadB64u || !sigB64u) return { ok: false, reason: "Token incompleto." };

    const expectedSig = await hmacSha256B64u(utf8Bytes(payloadB64u));
    if (expectedSig !== sigB64u) return { ok: false, reason: "Firma inválida (token alterado)." };

    let payload;
    try {
      payload = JSON.parse(utf8String(b64uDecodeToBytes(payloadB64u)));
    } catch {
      return { ok: false, reason: "Payload no es JSON válido." };
    }

    const lic_id = String(payload.lic_id || payload.license_id || "").trim();
    const user = String(payload.user || "").trim();
    const plan = String(payload.plan || "premium").trim();
    const exp = String(payload.exp || "").trim();

    if (!lic_id) return { ok: false, reason: "Falta lic_id en payload." };
    if (!exp) return { ok: false, reason: "Falta exp (YYYY-MM-DD) en payload." };

    const dleft = daysLeft(exp);
    if (!isFinite(dleft)) return { ok: false, reason: "Fecha exp inválida (use YYYY-MM-DD)." };
    if (dleft < 0) return { ok: false, reason: `Licencia vencida (${exp}).` };

    return { ok: true, lic_id, user, plan, exp, daysLeft: dleft, features: payload.features || {} };
  }

  // ---- PUBLIC verifyToken (OFFLINE + LOCK) ----
  async function verifyToken(token) {
    const base = await verifyTokenSignature(token);
    if (!base.ok) return { ok: false, reason: base.reason || "Licencia inválida." };

    // Device lock: primer uso fija el equipo
    const current = await deviceHashFor(base.lic_id);
    const bound = getBound(base.lic_id);

    if (!bound) {
      // primera activación: queda amarrada a este dispositivo
      setBound(base.lic_id, current);
      return {
        ok: true,
        lic_id: base.lic_id,
        user: base.user,
        plan: base.plan,
        exp: base.exp,
        daysLeft: base.daysLeft,
        features: base.features,
        lock: "bound_now"
      };
    }

    if (bound !== current) {
      return {
        ok: false,
        reason: "Esta licencia ya fue activada en otro equipo. (Bloqueo por dispositivo)"
      };
    }

    return {
      ok: true,
      lic_id: base.lic_id,
      user: base.user,
      plan: base.plan,
      exp: base.exp,
      daysLeft: base.daysLeft,
      features: base.features,
      lock: "bound_ok"
    };
  }

  window.PCLSOAT_LICENSE = { verifyToken, loadToken, saveToken, clearToken };
})();
