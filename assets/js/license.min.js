/* license.min.js — PCL-SOAT License Engine (HMAC + device binding + periodic check-in)
   Drop-in replacement for assets/js/license.min.js
   API: window.PCLSOAT_LICENSE = { verifyToken, loadToken, saveToken, clearToken }
*/
(function () {
  "use strict";

  // ===================== CONFIG (AJUSTA SOLO ESTO) =====================
  const STORAGE_KEY = "pclsoat_license_token_v1"; // app.min.js usa este key :contentReference[oaicite:3]{index=3}
  const DEVICE_KEY  = "pclsoat_device_id_v1";

  // Mantén tu secreto actual para no romper tokens existentes.
  // En tu repo actual, el minificado expone un SECRET (ej: "Sk1nn3r%%2025"). :contentReference[oaicite:4]{index=4}
  const SECRET = "Sk1nn3r%%2025";

  // Endpoint SAME-ORIGIN (no rompe CSP si tu CSP es 'self')
  // Debes publicar un handler en tu hosting: POST /api/checkin
  const CHECKIN_URL = "/api/checkin";

  // Tolerancia: si no hay internet, deja operar hasta X días desde el último check-in OK
  const GRACE_DAYS = 30;

  // Timeout de red para no congelar UX
  const CHECKIN_TIMEOUT_MS = 2500;
  // ====================================================================

  // --------------------- util b64url ---------------------
  function b64uEncodeBytes(bytes) {
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function b64uDecodeToBytes(b64u) {
    const b64 = b64u.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((b64u.length + 3) % 4);
    const str = atob(b64);
    const out = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) out[i] = str.charCodeAt(i);
    return out;
  }
  function utf8Bytes(s) { return new TextEncoder().encode(String(s)); }
  function utf8String(bytes) { return new TextDecoder().decode(bytes); }

  // --------------------- crypto helpers ---------------------
  async function sha256B64u(inputBytes) {
    const h = await crypto.subtle.digest("SHA-256", inputBytes);
    return b64uEncodeBytes(new Uint8Array(h));
  }
  async function hmacSha256B64u(messageBytes) {
    const key = await crypto.subtle.importKey(
      "raw",
      utf8Bytes(SECRET),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", key, messageBytes);
    return b64uEncodeBytes(new Uint8Array(sig));
  }

  // --------------------- date helpers ---------------------
  function parseISODate(iso) {
    // iso: YYYY-MM-DD
    if (!iso || typeof iso !== "string") return null;
    const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    const y = Number(m[1]), mo = Number(m[2]) - 1, d = Number(m[3]);
    const dt = new Date(Date.UTC(y, mo, d, 0, 0, 0));
    return isNaN(dt.getTime()) ? null : dt;
  }
  function daysLeft(expISO) {
    const exp = parseISODate(expISO);
    if (!exp) return NaN;
    const now = new Date();
    const nowUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0);
    const diffMs = exp.getTime() - nowUTC;
    return Math.floor(diffMs / 86400000);
  }
  function todayISO() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const da = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${da}`;
  }

  // --------------------- device id ---------------------
  function getOrCreateDeviceId() {
    let id = localStorage.getItem(DEVICE_KEY);
    if (id && id.length >= 16) return id;
    const buf = new Uint8Array(24);
    crypto.getRandomValues(buf);
    id = b64uEncodeBytes(buf);
    localStorage.setItem(DEVICE_KEY, id);
    return id;
  }
  async function deviceHashFor(lic_id) {
    const deviceId = getOrCreateDeviceId();
    // hash estable y no invasivo
    return sha256B64u(utf8Bytes(`${lic_id}::${deviceId}`));
  }

  // --------------------- token storage ---------------------
  function loadToken() { return (localStorage.getItem(STORAGE_KEY) || "").trim(); }
  function saveToken(t) { localStorage.setItem(STORAGE_KEY, String(t || "").trim()); }
  function clearToken() { localStorage.removeItem(STORAGE_KEY); }

  // --------------------- token verify (HMAC payloadB64u.signatureB64u) ---------------------
  async function verifyTokenSignature(token) {
    const parts = String(token || "").split(".");
    if (parts.length !== 2) return { ok: false, reason: "Formato inválido (se espera payload.signature)." };

    const payloadB64u = parts[0].trim();
    const sigB64u = parts[1].trim();
    if (!payloadB64u || !sigB64u) return { ok: false, reason: "Token incompleto." };

    const expectedSig = await hmacSha256B64u(utf8Bytes(payloadB64u));
    if (expectedSig !== sigB64u) return { ok: false, reason: "Firma inválida (token alterado)." };

    let payload;
    try {
      payload = JSON.parse(utf8String(b64uDecodeToBytes(payloadB64u)));
    } catch {
      return { ok: false, reason: "Payload no es JSON válido." };
    }

    // Campos mínimos
    const lic_id = String(payload.lic_id || payload.license_id || "").trim();
    const user = String(payload.user || "").trim();
    const plan = String(payload.plan || "premium").trim();
    const exp = String(payload.exp || "").trim();

    if (!lic_id) return { ok: false, reason: "Falta lic_id en payload." };
    if (!exp) return { ok: false, reason: "Falta exp (YYYY-MM-DD) en payload." };

    const dleft = daysLeft(exp);
    if (!isFinite(dleft)) return { ok: false, reason: "Fecha exp inválida (use YYYY-MM-DD)." };
    if (dleft < 0) return { ok: false, reason: `Licencia vencida (${exp}).` };

    // max_devices opcional (servidor lo aplicará)
    const max_devices = Number(payload.max_devices || 1);

    return {
      ok: true,
      lic_id,
      user,
      plan,
      exp,
      daysLeft: dleft,
      max_devices,
      features: payload.features || {}
    };
  }

  // --------------------- check-in logic ---------------------
  function lastCheckKey(lic_id) { return `pclsoat_last_checkin_${lic_id}`; }
  function getLastCheckinISO(lic_id) { return localStorage.getItem(lastCheckKey(lic_id)) || ""; }
  function setLastCheckinISO(lic_id, iso) { localStorage.setItem(lastCheckKey(lic_id), iso); }

  function graceOk(lic_id) {
    const last = getLastCheckinISO(lic_id);
    const lastDt = parseISODate(last);
    if (!lastDt) return false;
    const now = new Date();
    const nowUTC = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0);
    const diffDays = Math.floor((nowUTC - lastDt.getTime()) / 86400000);
    return diffDays <= GRACE_DAYS;
  }

  function withTimeout(promise, ms) {
    return new Promise((resolve) => {
      const t = setTimeout(() => resolve({ ok: false, timeout: true }), ms);
      promise.then((v) => { clearTimeout(t); resolve(v); }).catch(() => { clearTimeout(t); resolve({ ok: false }); });
    });
  }

  async function doCheckin(sigRes, token) {
    // SAME-ORIGIN POST /api/checkin
    // Envía lo mínimo: lic_id, device_hash, exp, max_devices, token (opcional pero útil para verificación server-side)
    const device_hash = await deviceHashFor(sigRes.lic_id);

    const body = {
      lic_id: sigRes.lic_id,
      device_hash,
      exp: sigRes.exp,
      max_devices: sigRes.max_devices,
      token
    };

    const resp = await withTimeout(
      fetch(CHECKIN_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
        cache: "no-store"
      }).then(async (r) => {
        if (!r.ok) return { ok: false, status: r.status };
        const j = await r.json().catch(() => ({}));
        return j && typeof j === "object" ? j : { ok: false };
      }),
      CHECKIN_TIMEOUT_MS
    );

    return resp;
  }

  // --------------------- public verifyToken ---------------------
  async function verifyToken(token) {
    const base = await verifyTokenSignature(token);
    if (!base.ok) return { ok: false, reason: base.reason || "Licencia inválida." };

    // Si hay internet, intenta check-in
    if (navigator.onLine) {
      const chk = await doCheckin(base, token);
      if (chk && chk.ok === true) {
        setLastCheckinISO(base.lic_id, todayISO());
        // server puede devolver flags/revocación
        return {
          ok: true,
          lic_id: base.lic_id,
          user: base.user,
          plan: base.plan,
          exp: base.exp,
          daysLeft: base.daysLeft,
          features: base.features,
          checkin: "ok",
          devices: chk.devices,
          max_devices: chk.max_devices
        };
      }

      // Si server niega explícitamente => FREE
      if (chk && chk.ok === false && chk.reason) {
        return { ok: false, reason: chk.reason }; // ej: "Licencia en 3 dispositivos. Máximo 1."
      }
      // Si falla red/timeout, cae a gracia si corresponde
    }

    // Offline o falló check-in: aplica gracia
    if (graceOk(base.lic_id)) {
      return {
        ok: true,
        lic_id: base.lic_id,
        user: base.user,
        plan: base.plan,
        exp: base.exp,
        daysLeft: base.daysLeft,
        features: base.features,
        checkin: "grace"
      };
    }

    return {
      ok: false,
      reason: `Requiere verificación (check-in) cada ${GRACE_DAYS} días. Conéctate a internet y valida.`
    };
  }

  // Expose
  window.PCLSOAT_LICENSE = { verifyToken, loadToken, saveToken, clearToken };
})();
