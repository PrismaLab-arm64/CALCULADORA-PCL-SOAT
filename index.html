<script>
/* =========================================================
   SIGNED LICENSE (NO DB) - WebCrypto ECDSA P-256
   - No rompe tu sistema actual.
   - Activa Premium con token firmado localmente.
   ========================================================= */

(function () {
  // ====== CONFIG ======
  const LS_KEY = "pcl_signed_license_token_v1";

  // Reemplaza esto por tu clave pública real (JWK) cuando la generemos.
  // Por ahora deja este ejemplo para que el código quede listo.
  const PUBLIC_KEY_JWK = {
    "kty":"EC",
    "crv":"P-256",
    "x":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "y":"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    "ext":true
  };

  // El token esperado tiene formato:
  // base64url(payloadJSON) + "." + base64url(signatureDERorRAW)
  // payloadJSON incluye: user, plan, exp (YYYY-MM-DD), features, lic_id, issued_at
  //
  // Nota: aquí usamos firma ECDSA P-256 y signature "raw" (r||s, 64 bytes) en base64url.
  // (Cuando generemos licencias, generaremos firma en ese formato.)

  // ====== Helpers ======
  const $ = (id) => document.getElementById(id);
  const b64uToBytes = (b64u) => {
    const b64 = b64u.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((b64u.length + 3) % 4);
    const str = atob(b64);
    const bytes = new Uint8Array(str.length);
    for (let i=0; i<str.length; i++) bytes[i] = str.charCodeAt(i);
    return bytes;
  };
  const bytesToText = (bytes) => new TextDecoder().decode(bytes);
  const parseISODate = (s) => {
    // "YYYY-MM-DD"
    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(s||"").trim());
    if (!m) return null;
    const dt = new Date(Date.UTC(+m[1], +m[2]-1, +m[3], 0, 0, 0));
    return isNaN(dt.getTime()) ? null : dt;
  };
  const daysLeft = (expISO) => {
    const exp = parseISODate(expISO);
    if (!exp) return null;
    const now = new Date();
    const utcNow = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0,0,0));
    const diffMs = exp.getTime() - utcNow.getTime();
    return Math.floor(diffMs / 86400000);
  };

  async function importPublicKey() {
    return crypto.subtle.importKey(
      "jwk",
      PUBLIC_KEY_JWK,
      { name: "ECDSA", namedCurve: "P-256" },
      true,
      ["verify"]
    );
  }

  async function verifyToken(token) {
    token = String(token || "").trim();
    if (!token || token.indexOf(".") === -1) {
      return { ok: false, err: "Token inválido: formato esperado payload.signature" };
    }

    const [payloadB64u, sigB64u] = token.split(".", 2);
    if (!payloadB64u || !sigB64u) {
      return { ok: false, err: "Token inválido: payload o firma vacíos" };
    }

    let payloadJson;
    try {
      const payloadBytes = b64uToBytes(payloadB64u);
      payloadJson = JSON.parse(bytesToText(payloadBytes));
    } catch (e) {
      return { ok: false, err: "Payload inválido: no es JSON válido" };
    }

    // Validaciones mínimas
    const user = String(payloadJson.user || "").trim();
    const plan = String(payloadJson.plan || "").trim().toLowerCase();
    const exp = String(payloadJson.exp || "").trim();
    if (!user || !plan || !exp) {
      return { ok: false, err: "Payload incompleto: requiere user, plan, exp" };
    }

    // Verifica expiración
    const dl = daysLeft(exp);
    if (dl === null) return { ok: false, err: "Fecha exp inválida (use YYYY-MM-DD)" };
    if (dl < 0) return { ok: false, err: "Licencia vencida" };

    // Verifica firma
    try {
      const pub = await importPublicKey();
      const sigBytes = b64uToBytes(sigB64u); // firma raw r||s (64 bytes)
      if (sigBytes.length !== 64) {
        return { ok: false, err: "Firma inválida: tamaño esperado 64 bytes (r||s)" };
      }
      const data = new TextEncoder().encode(payloadB64u); // firma sobre payloadB64u (no sobre JSON raw)
      const ok = await crypto.subtle.verify(
        { name: "ECDSA", hash: "SHA-256" },
        pub,
        sigBytes,
        data
      );
      if (!ok) return { ok: false, err: "Firma no válida" };
    } catch (e) {
      return { ok: false, err: "Error verificando firma: " + (e && e.message ? e.message : String(e)) };
    }

    return { ok: true, payload: payloadJson };
  }

  // ====== Premium State ======
  function setPremiumUI(state) {
    // state: { premium:boolean, user?:string, plan?:string, exp?:string, features?:object }
    const premium = !!state.premium;
    const statusEl = $("premiumStatus");
    const userEl = $("premiumUser");
    const daysEl = $("premiumDays");
    const btnClear = $("btnClearPremium");

    if (premium) {
      const d = daysLeft(state.exp);
      statusEl.innerHTML = `Estado: <b>PREMIUM</b>`;
      userEl.style.display = "";
      daysEl.style.display = "";
      userEl.textContent = `Usuario: ${state.user || "—"} | Plan: ${String(state.plan||"premium").toUpperCase()}`;
      daysEl.textContent = `Vence: ${state.exp || "—"} | Días restantes: ${d !== null ? d : "—"}`;
      btnClear.style.display = "";
    } else {
      statusEl.innerHTML = `Estado: <b>FREE</b>`;
      userEl.style.display = "none";
      daysEl.style.display = "none";
      btnClear.style.display = "none";
    }

    // Hook para tu lógica existente:
    // Guardamos un flag global (no rompe nada).
    window.__PCL_PREMIUM__ = premium;
    window.__PCL_LICENSE__ = state || {};
    // Si tienes un selector de año con 2027 deshabilitado, lo re-habilitamos aquí si corresponde:
    enableYear2027IfAllowed();
  }

  function enableYear2027IfAllowed() {
    // Si tu selector de año tiene option value="2027" o texto "2027", intentamos habilitarlo sin romper.
    const premium = !!window.__PCL_PREMIUM__;
    const features = (window.__PCL_LICENSE__ && window.__PCL_LICENSE__.features) ? window.__PCL_LICENSE__.features : {};
    const allow2027 = premium && (features.y2027 === true || features.year2027 === true || features["2027"] === true || Object.keys(features).length === 0);
    // "allow2027" por defecto true si premium y no hay features (no bloqueamos por defecto).
    const selects = document.querySelectorAll("select");
    selects.forEach(sel => {
      const opt = Array.from(sel.options || []).find(o => String(o.value) === "2027" || /2027/.test(o.text || ""));
      if (opt) opt.disabled = !allow2027;
    });
  }

  function showMsg(txt, ok) {
    const el = $("premiumMsg");
    if (!el) return;
    el.textContent = txt;
    el.style.color = ok ? "inherit" : "rgba(255,120,120,1)";
    el.style.opacity = "1";
  }

  async function loadExistingToken() {
    const token = localStorage.getItem(LS_KEY);
    if (!token) {
      setPremiumUI({ premium: false });
      return;
    }
    const res = await verifyToken(token);
    if (!res.ok) {
      // Si el token guardado ya no valida, lo limpiamos para evitar bloqueos raros.
      localStorage.removeItem(LS_KEY);
      setPremiumUI({ premium: false });
      return;
    }
    const p = res.payload;
    setPremiumUI({ premium: true, user: p.user, plan: p.plan, exp: p.exp, features: p.features || {}, lic_id: p.lic_id, issued_at: p.issued_at });
  }

  // ====== UI wiring ======
  function togglePremiumBox(show) {
    const box = $("premiumBox");
    if (!box) return;
    box.style.display = show ? "" : "none";
  }

  async function onValidate() {
    const input = $("licenseTokenInput");
    const token = (input && input.value) ? input.value.trim() : "";
    if (!token) {
      showMsg("Pega un token o carga un archivo de licencia.", false);
      return;
    }
    const res = await verifyToken(token);
    if (!res.ok) {
      showMsg("❌ " + res.err, false);
      return;
    }
    localStorage.setItem(LS_KEY, token);
    const p = res.payload;
    setPremiumUI({ premium: true, user: p.user, plan: p.plan, exp: p.exp, features: p.features || {}, lic_id: p.lic_id, issued_at: p.issued_at });
    showMsg("✅ Licencia validada. Premium activado.", true);
    togglePremiumBox(false);
  }

  function onClear() {
    localStorage.removeItem(LS_KEY);
    $("licenseTokenInput") && ($("licenseTokenInput").value = "");
    showMsg("Licencia eliminada. Modo FREE.", true);
    setPremiumUI({ premium: false });
  }

  function wireEvents() {
    const openBtn = $("btnOpenPremium");
    const closeBtn = $("btnClosePremium");
    const clearBtn = $("btnClearPremium");
    const validateBtn = $("btnValidateLicense");
    const fileInput = $("licenseFileInput");

    if (openBtn) openBtn.addEventListener("click", () => togglePremiumBox(true));
    if (closeBtn) closeBtn.addEventListener("click", () => togglePremiumBox(false));
    if (clearBtn) clearBtn.addEventListener("click", onClear);
    if (validateBtn) validateBtn.addEventListener("click", onValidate);

    if (fileInput) {
      fileInput.addEventListener("change", async (e) => {
        try {
          const f = e.target.files && e.target.files[0];
          if (!f) return;
          const text = await f.text();
          $("licenseTokenInput").value = String(text || "").trim();
          showMsg("Archivo cargado. Pulsa “Validar licencia”.", true);
        } catch (err) {
          showMsg("No se pudo leer el archivo.", false);
        }
      });
    }
  }

  // ====== init ======
  document.addEventListener("DOMContentLoaded", async () => {
    try {
      wireEvents();
      await loadExistingToken();
      // Mantén compatibilidad: si tu lógica actual usa licencia_valora.json, no la tocamos aún.
      // En la fase 2 la retiramos.
    } catch (e) {
      setPremiumUI({ premium: false });
    }
  });

})();
</script>
